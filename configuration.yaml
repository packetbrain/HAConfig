homeassistant:
  name: Home
  latitude: !secret latitude
  longitude: !secret longitude
  elevation: 66
  unit_system: imperial
  time_zone: America/New_York
  whitelist_external_dirs: /config

  customize: !include customize.yaml

  customize_glob:
    "switch.tv_*":
      icon: mdi:power-socket-eu
      google_assistant: true   
    "switch.onkyo_*":
#      assumed_state: false 
      icon: mdi:power-socket-eu
# while "assumed_state" did turn the remote controls into toggles... 
#doesnt help the use case
#
#
# The next line caused logic problems with HAASKA
#   not filtering at this global level
#
#    "*.*":
#      haaska_hidden: false
#
#
# Then we whitelist 3 domains for HAASKA
#
#
  customize_domain:
    automation:
      hidden: true
#    light:
#      haaska_hidden: false
#    script:
#      haaska_hidden: false
#    cover:
#      haaska_hidden: false
#    switch:
#      haaska_hidden: true
#    group:
#      haaska_hidden: true

#
#
# Then whitelist specific entities in customize.yaml
#
#


automation: !include automation.yaml
script: !include script.yaml
light: !include light.yaml
sensor: !include sensor.yaml
notify: !include notify.yaml
group: !include_dir_merge_named group/
google_assistant: !include google_assistant.yaml
alexa: !include alexa.yaml
device_tracker: !include device_tracker.yaml


api:
sun:
config:



frontend:
  themes:
    Mom:
      primary-color: pink
    Dad:
      primary-color: blue



mqtt:
  broker: 7.7.7.99
  client_id: home-assistant-1
#  user: cisco
#  password: cisco



http:
  api_password: !secret http_api_pass
  ssl_certificate: /certs/fullchain.pem
  ssl_key: /certs/privkey.pem
  base_url: !secret base_url



logger:
  default: debug
  logs:
    homeassistant.components.recorder.util: info
    homeassistant.components.history: info
    homeassistant.components.websocket_api: info
    roku: info
    panasonic_viera: info
# see docs https://www.home-assistant.io/components/logger/
# use whatever you see in square brackets in the log as the filter name here



recorder:
#number of history days to keep in recorder database after a purge.
  purge_keep_days: 10
# How often (in days) the purge task runs
  purge_interval: 1
  include:
    domains:
      - light
      - cover
      - automation
      - script
      - sensor
      - media_player
    entities:
     - group.family_room
     - group.kitchen
     - sun.sun
     - sensor.speedtest_download
     - sensor.speedtest_upload
     - sensor.speedtest_ping
# This should keep db size down a bit... 
# used different domain/entity list for history and recorder components
#   so that I could control display order for "history"



history:
  use_include_order: True
#  hours_to_show: 48
  include:
#    domains:
#      - light
#      - cover
    entities:
     - cover.garage
     - light.Table
     - light.Island
     - light.Top
     - light.Fireplace
     - light.Foyer
     - light.Tall
     - sun.sun
     - sensor.speedtest_download
     - sensor.speedtest_upload
     - sensor.speedtest_ping
# Note entities configured here are shown *before* a) their specific domains b) all domains
# not counting sensors which are graphed below

logbook:
  include:
    entities:
      - group.kitchen
      - group.family_room
  exclude:
    domains:
      - group



panel_iframe:
  radar_embed:
    title: 'Weather Radar'
    icon: mdi:weather-snowy-rainy
    url: /local/darksky_radar.html

  graphbar:
    title: '24 Hr. Forecast'
    icon: mdi:weather-sunset-up
    url: /local/darksky_graphbar.html

  default_embed:
    title: '7 Day Forecast'
    icon: mdi:calendar
    url: /local/darksky_default.html



#panel_custom:
#  - name: reactpanel
#    sidebar_title: Example
#    sidebar_icon: mdi:checkbox-marked-outline
#    url_path: weather
#    js_url: 'https://darksky.net/widget/default/42.360082,-71.05888/us12/en.js'
#    embed_iframe: true



camera:
  platform: generic
  name: RDU
#  limit_refetch_to_url_change: true
  still_image_url: !secret camera.rdu_still_image_url



alert:
  garage:
    name: Garage open 30 minutes
    entity_id: cover.garage
    state: 'open'   # Optional, 'on' is the default value
    repeat: 30
    can_acknowledge: true  # Optional, default is true
    skip_first: true  # Optional, false is the default
    notifiers:
      - alexas



input_number:
  temp:
    name: A/C Setting
    initial: 74
    min: 60
    max: 99
    step: 1



cover:
  - platform: mqtt
    name: "Garage"
# the "2" below is set by the "switchtopic" command - can be any number/word
#    state_topic: "cmnd/2/POWER2"
    state_topic: "stat/garage/POWER2"
    command_topic: "cmnd/garage/power1"
    availability_topic: "tele/garage/LWT"
#all three of these are ON - because the Tasmota just sends a pulse
    payload_open: "ON"
    payload_close: "ON"
    payload_stop: "ON"
#you can actually customize the state payloads from Tasmota with "StateTextx"
    state_open: "ON"
    state_closed: "OFF"
    payload_available: "Online"
    payload_not_available: "Offline"
    optimistic: false
    retain: false



media_player:
  - platform: panasonic_viera
    host: 7.7.7.242
    mac: 8c:c1:21:60:26:0b
  - platform: roku
    host: 7.7.7.243
  - platform: plex
    host: 7.7.7.99
    show_all_controls: true
    entity_namespace: 'plex'
    use_custom_entity_ids: true



counter:
  mycounter:
    initial: 30
    step: 1



switch:
  - platform: broadlink
    host: 7.7.5.66
    mac: 34:ea:34:e3:af:7f 
    timout: 5
    switches:
      !include_dir_merge_named broadlink

  - platform: template
    switches:
      garage_door:
        value_template: "{{ is_state('cover.garage', 'closed') }}"
        turn_on:
          service: cover.open_cover
          data:
            entity_id: cover.garage
        turn_off:
          service: cover.close_cover
          data:
            entity_id: cover.garage
        icon_template: >-
          {% if is_state('cover.garage', 'closed') %}
            mdi:garage
          {% else %}
            mdi:garage-open
          {% endif %}

input_boolean:
  switch_tv:
    name: for testing lovelaceUI
    initial: off
    icon: mdi:car

